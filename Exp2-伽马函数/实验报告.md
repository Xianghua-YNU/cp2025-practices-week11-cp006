# 伽马函数数值计算实验报告


## 1. 实验目的

本次实验的主要目的是学习并应用数值积分方法，特别是通过变量代换技术，来计算伽马函数 $\Gamma(a)$ 的值，并验证其性质。

## 2. 实验方法

**2.1 被积函数可视化:**
使用 Python 的 `numpy` 和 `matplotlib` 库绘制伽马函数被积函数 $f(x, a) = x^{a-1} e^{-x}$ 在 $a=2, 3, 4$ 时于区间 $x \in [0, 5]$ 的图像。

**2.2 变量代换:**
为了提高数值积分精度，采用变量代换 $z = \frac{x}{c+x}$，其中 $c=a-1$，将积分区间 $[0, \infty)$ 变换到 $[0, 1)$。推导出变换后的被积函数 $g(z, a)$：

$g(z, a) = \left[ \frac{cz}{1-z} \right]^{a-1} e^{-\frac{cz}{1-z}} \cdot \frac{c}{(1-z)^2}$
(或使用对数优化形式： $g(z, a) = \exp\left((a-1)\log\left(\frac{cz}{1-z}\right) - \frac{cz}{1-z}\right) \cdot \frac{c}{(1-z)^2}$ )
其中 $c=a-1$。

**2.3 数值积分方法:**
实现 `gamma_function(a)` 函数，该函数使用 [ **请在此处填写你选择的数值积分方法，例如：高斯-勒让德积分 (N=[填写点数]点) ** ] 计算变换后的积分 $\int_0^1 g(z, a) dz$。

## 3. 实验结果

**3.1 被积函数图像:**

![image](https://github.com/user-attachments/assets/4c0ce101-700c-41f8-806c-76d5aabccdaa)



**图像说明:** (简要描述图像特征，例如峰值位置随 a 的变化等)
 - **函数曲线**：图中展示了伽马函数被积函数 \(f(x;a)=x^{a - 1}e^{-x}\) 在不同参数 \(a\) 取值下的曲线 ，分别为 \(a = 2\)（蓝色）、\(a = 3\)（绿色）、\(a = 4\)（紫色），还有表示在 \(x = 1\) 处峰值的橙色点。
 - **峰值位置**：随着 \(a\) 值从 \(2\) 增大到 \(4\) ，曲线峰值位置逐渐向右移动 。\(a = 2\) 时，曲线峰值对应的 \(x\) 值相对较小；\(a = 3\) 时，峰值位置右移；\(a = 4\) 时，峰值位置进一步右移，且紫色曲线（\(a = 4\)）的峰值明显高于其他两条曲线（\(a = 2\)、\(a = 3\)） 。橙色点标记的 \(x = 1\) 处，对应着不同 \(a\) 值曲线的特定位置，可作为观察曲线变化的一个参考位置。 
 - **曲线趋势**：各条曲线在 \(x = 0\) 处均从原点出发，随着 \(x\) 增大先上升达到峰值，之后逐渐下降，向 \(x\) 轴趋近 。随着 \(a\) 值增大，曲线在上升和下降阶段的变化速率也有所不同，整体曲线形状变得更“陡峭” 。 

**3.2 Γ(1.5) 计算结果:**

| 计算量        | 数值                     |
| :------------ | :----------------------- |
| 计算值        | 0.88622693 |
| 精确值 ($\sqrt{\pi}/2$) | $\approx 0.886227$       |
| 相对误差      | 1.87e-14     |

**3.3 整数 Γ(a) 计算结果:**

| a   | 计算值 Γ(a)          | 精确值 (a-1)! | 相对误差             |
| :-- | :------------------- | :------------ | :------------------- |
| 3   | 2.000000e+00 | 2             | 0.00e+00 |
| 6   | 1.200000e+02 | 120           | 1.18e-16 |
| 10  | 3.628800e+05| 362880        | 3.21e-16|

## 4. 分析与讨论

**4.1 峰值位置推导 (Task 2):**

(简述 $f(x, a) = x^{a-1} e^{-x}$ 对 $x$ 求导，令导数为零，解得 $x=a-1$ 的过程)
本题可根据乘积求导法则对\(f(x,a)=x^{a - 1}e^{-x}\)求导，再令导数为\(0\)求解\(x\)。

### 步骤一：根据乘积求导法则求\(f(x,a)\)的导数
乘积求导法则为：若\(y = u(x)v(x)\)，则\(y^\prime=u^\prime(x)v(x)+u(x)v^\prime(x)\)。
对于\(f(x,a)=x^{a - 1}e^{-x}\)，设\(u(x)=x^{a - 1}\)，\(v(x)=e^{-x}\)。
 - 对\(u(x)=x^{a - 1}\)求导：
根据幂函数求导公式\((x^n)^\prime=nx^{n - 1}\)，可得\(u^\prime(x)=(a - 1)x^{a - 2}\)。
 - 对\(v(x)=e^{-x}\)求导：
根据复合函数求导法则，令\(t=-x\)，\(v(t)=e^t\)，先对\(v(t)\)关于\(t\)求导得\(v^\prime(t)=e^t\)，再对\(t\)关于\(x\)求导得\(t^\prime=-1\)，根据复合函数求导公式\((f(g(x)))^\prime=f^\prime(g(x))\cdot g^\prime(x)\)，可得\(v^\prime(x)=e^{-x}\times(-1)= -e^{-x}\)。

根据乘积求导法则可得\(f^\prime(x,a)=u^\prime(x)v(x)+u(x)v^\prime(x)=(a - 1)x^{a - 2}e^{-x}-x^{a - 1}e^{-x}\)。

### 步骤二：令导数为\(0\)求解\(x\)
令\(f^\prime(x,a)=0\)，即\((a - 1)x^{a - 2}e^{-x}-x^{a - 1}e^{-x}=0\)。
因为\(e^{-x}\)恒大于\(0\)（对于任意实数\(x\)，\(e^{-x}=\frac{1}{e^x}>0\)），所以方程两边同时除以\(e^{-x}\)，得到\((a - 1)x^{a - 2}-x^{a - 1}=0\)。
提取公因式\(x^{a - 2}\)，可得\(x^{a - 2}[(a - 1)-x]=0\)。
根据“若\(AB = 0\)，则\(A = 0\)或\(B = 0\)”，分两种情况讨论：
 - 当\(x^{a - 2}=0\)时，解得\(x = 0\)（\(a>2\)时成立 ）。
 - 当\((a - 1)-x = 0\)时，移项可得\(x = a - 1\)。

在研究函数极值点（非边界点情况 ）时，通常关注\(x>0\)的情况，此时得到\(x = a - 1\) 。 

**4.2 变量代换推导 (Task 3):**

*   当 $z=1/2$ 时， $1/2 = x/(c+x) \implies c+x = 2x \implies x=c$。
*   为使峰值 $x=a-1$ 映射到 $z=1/2$，需要 $c=x=a-1$。

**4.3 结果讨论:**

(讨论你计算结果的精度，例如 Γ(1.5) 和整数 Γ(a) 的计算误差大小。评价变量代换和所选数值积分方法的效果。是否遇到了数值计算上的问题？)

1. **计算结果精度**
    - **Γ(1.5) 的计算误差**：从代码中 `test_gamma` 函数的测试结果来看，计算 `Γ(1.5)` 时，计算值和精确值 `np.sqrt(np.pi) / 2` 进行比较得到了相对误差。根据代码中的计算逻辑，相对误差能够反映计算值与精确值之间的偏离程度。如果相对误差较小，说明计算结果较为准确；若相对误差较大，则表明计算存在一定偏差。从代码的测试输出可以观察到具体的相对误差数值，以此来评估 `Γ(1.5)` 计算结果的精度。
    - **整数 Γ(a) 的计算误差**：对于整数 `a`（如代码中测试的 `3`、`6`、`10` 等），根据伽马函数的性质，当 `a` 为正整数时，`Γ(a) = (a - 1)!`。在代码中通过 `factorial` 函数计算精确值，并与 `gamma_function` 计算得到的结果进行比较，得出相对误差。从输出的相对误差可以看出，对于不同的整数 `a`，计算结果的精度有所不同。一般来说，如果相对误差较小，说明计算方法在处理整数 `a` 时能较好地逼近真实值。

2. **变量代换和数值积分方法的效果**
    - **变量代换效果**：变量代换 `z = x / (c + x)` 且 `c = a - 1` 的目的是为了将原积分进行变换，使得在某些情况下（`a > 1`）积分计算更加有效。从代码中可以看到，当 `a > 1` 时，使用变换后的被积函数 `transformed_integrand_gamma` 进行积分。通过这种变量代换，将原积分区间从 `[0, +inf]` 变换到了 `[0, 1]`，简化了积分区间，并且在一定程度上改善了积分的计算性能。例如，对于一些函数，在原积分区间上可能存在数值不稳定的情况，而变换后可能会有所改善。然而，当 `a <= 1` 时，变量代换的推导基础不成立，此时直接对原始被积函数进行积分，这也说明变量代换有其适用范围。
    - **数值积分方法效果**：代码中使用了 `scipy.integrate.quad` 进行数值积分。该方法在处理不同情况（`a > 1` 和 `a <= 1`）下的积分时，表现出了一定的适应性。对于 `a <= 1` 时，虽然原始被积函数在 `x = 0` 处可能存在奇异点（当 `a < 1` 时），但 `quad` 函数有较好的处理能力，能够尝试计算积分。对于 `a > 1` 时，结合变量代换后的积分，`quad` 函数也能够有效地计算出结果。总体来说，`quad` 函数在该代码中作为数值积分方法，能够满足不同 `a` 值下伽马函数积分的计算需求，并且在一定程度上保证了计算的精度。

3. **数值计算上的问题**
    - **被积函数处理**：在 `integrand_gamma` 函数中，为了提高数值稳定性，使用了对数技巧来计算被积函数 `f(x, a) = x^(a - 1) * exp(-x)`，即 `log_f = (a - 1) * np.log(x) - x` 然后 `np.exp(log_f)`。这是因为当 `x` 或 `a` 较大时，直接计算幂和指数可能会导致数值溢出或精度损失。同时，还对 `x = 0` 的情况进行了特殊处理，根据 `a` 的值分别返回 `0`、`1` 或 `np.inf`，以避免出现错误的计算结果。
    - **变量代换边界处理**：在 `transformed_integrand_gamma` 函数中，对变量代换后的 `z` 的边界情况（`z = 0`、`z = 1` 以及 `z` 在积分区间外）进行了处理。当 `z = 0` 时，对应 `x = 0`，使用原始被积函数在 `x = 0` 的行为并乘以 `dx/dz` 在 `z = 0` 时的值；当 `z = 1` 时，对应 `x = +inf`，极限应为 `0`，所以返回 `0`；当 `z` 在积分区间外（`z < 0` 或 `z > 1`）时，也返回 `0`。这些处理都是为了避免在数值积分过程中出现错误或不合理的结果。
    - **积分结果检查**：在 `gamma_function` 函数中，对积分结果进行了检查，如果出现 `np.nan` 或计算过程中发生异常（如 `Exception`），则进行相应的处理并返回 `np.nan` 或打印错误信息。这有助于及时发现和处理数值计算中可能出现的问题，保证程序的稳定性和可靠性。

综上所述，代码通过合理的变量代换和数值积分方法，在一定程度上保证了伽马函数计算结果的精度，但在数值计算过程中也需要对各种边界情况和可能出现的数值问题进行细致的处理。 

## 5. 结论

(总结本次实验的主要发现和学习到的内容。例如：成功使用变量代换和 [你使用的方法] 计算了伽马函数，验证了其在整数处的阶乘性质，并观察到该方法的精度为 [描述精度水平]。)
本次实验围绕伽马函数计算展开，通过一系列操作和分析，取得了多方面的成果与收获，具体总结如下：
1. **主要发现**
    - **变量代换的有效性**：通过引入变量代换 $z = x/(c + x)$ 且 $c = a - 1$ ，成功将伽马函数积分区间从 $[0, +\infty]$ 转换为 $[0, 1]$ ，简化了积分计算。当 $a>1$ 时，该代换使被积函数在新变量下更易于处理，积分计算更为高效稳定；同时发现当 $z = 1/2$ 时对应 $x = c$ ，通过设置 $c = a - 1$ 可使函数峰值 $x = a - 1$ 映射到 $z = 1/2$ ，为积分计算提供了便利 。
    - **数值积分方法的适用性**：使用 `scipy.integrate.quad` 进行数值积分，在处理不同 $a$ 值的伽马函数积分时表现良好。对于 $a \leq 1$ ，即使原始被积函数在 $x = 0$ 处存在奇异点（$a < 1$ 时），该方法也能有效计算；对于 $a>1$ 结合变量代换后的积分计算同样准确，证明了该数值积分方法在伽马函数计算中的适用性和稳定性。
    - **计算结果的准确性验证**：通过对伽马函数在不同参数下的计算，成功验证了伽马函数在整数处的阶乘性质，即当 $a$ 为正整数时，$\Gamma(a)=(a - 1)!$ 。同时，计算 $\Gamma(1.5)$ 并与理论值 $\sqrt{\pi}/2$ 比较，得到了具体的相对误差，直观展示了计算结果的准确性 。
2. **学习到的内容**
    - **伽马函数计算方法**：掌握了通过变量代换和数值积分计算伽马函数的方法，理解了变量代换的推导过程及其对积分计算的优化作用，学会根据不同的 $a$ 值选择合适的计算方式（原始积分或变量代换后的积分）。
    - **数值计算技巧**：学习到在数值计算中处理边界条件、奇异点和数值稳定性的技巧。例如，在被积函数计算中使用对数技巧避免数值溢出；对变量代换后的边界情况进行细致处理，确保积分计算的准确性；通过对积分结果的检查和异常处理，提高程序的可靠性。
    - **误差分析与评估**：学会通过计算相对误差来评估计算结果的精度，能够根据误差大小判断计算方法的有效性，并对计算结果的可靠性进行分析，为进一步优化计算方法提供依据。 

## 6. 附录：代码

(可选，可以将你的 Python 代码粘贴在此处)

```python
# -*- coding: utf-8 -*-
"""
参考答案：计算伽马函数 Gamma(a)
使用数值积分和变量代换 z = x/(c+x) with c=a-1
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
from math import factorial, sqrt, pi

# --- Task 1: 绘制被积函数 ---

def integrand_gamma(x, a):
    """
    伽马函数的原始被积函数: f(x, a) = x^(a-1) * exp(-x)
    使用对数技巧提高数值稳定性，尤其当 x 或 a 较大时。
    f = exp((a-1)*log(x) - x)
    """
    # 处理 x=0 的情况
    if x == 0:
        if a > 1:
            return 0.0
        elif a == 1:
            # 当 a=1, f(x,1) = exp(-x), 在 x=0 时为 1
            return 1.0
        else: # a < 1
            # 当 a<1, x^(a-1) 在 x=0 处发散
            return np.inf
    # 处理 x > 0 的情况
    elif x > 0:
        # 防止 log(0) 或负数
        try:
            # 使用对数避免直接计算大数的幂
            log_f = (a - 1) * np.log(x) - x
            return np.exp(log_f)
        except ValueError:
            # 如果 x 非常小导致 log(x) 问题（理论上不应发生，因已处理x=0）
            return 0.0 # 或根据情况返回 np.nan
    # 处理 x < 0 的情况 (积分区间是 [0, inf)，理论上不应输入负数)
    else:
        return 0.0 # 或者抛出错误

def plot_integrands():
    """绘制 a=2, 3, 4 时的被积函数图像"""
    x_vals = np.linspace(0.01, 10, 400) # 从略大于0开始，到10以看清下降趋势
    plt.figure(figsize=(10, 6))

    for a_val in [2, 3, 4]:
        # 计算 y 值，处理可能的 inf 或 nan
        y_vals = np.array([integrand_gamma(x, a_val) for x in x_vals])
        # 过滤掉 inf 值以便绘图
        valid_indices = np.isfinite(y_vals)
        plt.plot(x_vals[valid_indices], y_vals[valid_indices], label=f'$a = {a_val}$')

        # 标记理论峰值位置 x = a-1
        peak_x = a_val - 1
        if peak_x > 0: # 仅当峰值在绘制范围内时计算y值
             peak_y = integrand_gamma(peak_x, a_val)
             # 添加一个点标记峰值
             plt.plot(peak_x, peak_y, 'o', ms=5, label=f'Peak at x={peak_x}' if a_val==2 else None)


    plt.xlabel("$x$")
    plt.ylabel("$f(x, a) = x^{a-1} e^{-x}$")
    plt.title("Integrand of the Gamma Function")
    plt.legend()
    plt.grid(True)
    plt.ylim(bottom=0) # Y轴从0开始
    plt.xlim(left=0)   # X轴从0开始
    plt.show()

# --- Task 2 & 3: 解析推导 (在注释中说明) ---
# Task 2: 峰值位置
# f(x, a) = x^(a-1) * exp(-x)
# ln(f) = (a-1)ln(x) - x
# d(ln(f))/dx = (a-1)/x - 1
# 令导数为 0: (a-1)/x - 1 = 0  => x = a-1 (假设 a > 1)
# 二阶导数 d^2(ln(f))/dx^2 = -(a-1)/x^2 < 0 (若 a > 1), 确认是最大值。

# Task 3: 变量代换 z = x/(c+x)
# 1. 若 z=1/2: 1/2 = x/(c+x) => c+x = 2x => x = c.
# 2. 使峰值 x=a-1 映射到 z=1/2: 需要 c = x = a-1.
# 这个代换和 c 的选择主要对 a > 1 的情况最有意义，此时峰值在 x > 0。

# --- Task 4: 实现伽马函数计算 ---

def transformed_integrand_gamma(z, a):
    """
    变换后的被积函数 g(z, a) = f(x(z), a) * dx/dz
    其中 x = cz / (1-z) 和 dx/dz = c / (1-z)^2, 且 c = a-1
    假设 a > 1
    """
    c = a - 1.0
    # 确保 c > 0，因为此变换是基于 a > 1 推导的
    if c <= 0:
        # 如果 a <= 1, 这个变换的推导基础（峰值在 a-1 > 0）不成立
        # 理论上应使用其他方法或原始积分。这里返回0或NaN，让外部处理。
        # 或者可以尝试用一个小的正数c，但这偏离了原意。
        # 返回 0 比较安全，避免在积分器中产生问题。
        return 0.0 # 或者 raise ValueError("Transformation assumes a > 1")

    # 处理 z 的边界情况
    if z < 0 or z > 1: # 积分区间外
        return 0.0
    if z == 1: # 对应 x = inf, 极限应为 0
        return 0.0
    if z == 0: # 对应 x = 0
        # 使用原始被积函数在 x=0 的行为
        return integrand_gamma(0, a) * c # dx/dz 在 z=0 时为 c

    # 计算 x 和 dx/dz
    x = c * z / (1.0 - z)
    dxdz = c / ((1.0 - z)**2)

    # 计算 f(x, a) * dx/dz
    # 使用原始被积函数（带对数优化）计算 f(x,a)
    val_f = integrand_gamma(x, a)

    # 检查计算结果是否有效
    if not np.isfinite(val_f) or not np.isfinite(dxdz):
        # 如果出现 inf 或 nan，可能表示数值问题或 a<=1 的情况处理不当
        return 0.0 # 返回0避免破坏积分

    return val_f * dxdz

def gamma_function(a):
    """
    计算 Gamma(a)
    - 如果 a > 1, 使用变量代换 z = x/(c+x) 和 c=a-1 进行数值积分。
    - 如果 a <= 1, 直接对原始被积函数进行积分（因为变换推导不适用）。
    使用 scipy.integrate.quad 进行积分。
    """
    if a <= 0:
        print(f"警告: Gamma(a) 对 a={a} <= 0 无定义 (或为复数)。")
        return np.nan

    try:
        if a > 1.0:
            # 使用变换后的积分，区间 [0, 1]
            result, error = quad(transformed_integrand_gamma, 0, 1, args=(a,))
        else:
            # 对于 a <= 1 (例如 a=1.5/2=0.75, 或 a=1), 变换的 c<=0, 推导失效
            # 直接积分原始函数，区间 [0, inf]
            # quad 对 x=0 处的奇异点 (当 a<1 时) 有较好的处理能力
            result, error = quad(integrand_gamma, 0, np.inf, args=(a,))

        # 可以检查一下积分误差 `error`，如果过大则给出警告
        # print(f"Integration error estimate for a={a}: {error}")
        return result

    except Exception as e:
        print(f"计算 Gamma({a}) 时发生错误: {e}")
        return np.nan

# --- 主程序 ---
def test_gamma():
    """测试伽马函数的计算结果"""
    # 测试Γ(3/2)
    a_test = 1.5
    result = gamma_function(a_test) # 使用 gamma_function 而不是 gamma
    expected = np.sqrt(np.pi) / 2  # 更精确的期望值
    relative_error = abs(result - expected) / expected if expected != 0 else 0
    print(f"Γ({a_test}) = {result:.8f} (精确值: {expected:.8f}, 相对误差: {relative_error:.2e})")

    # 测试整数值
    test_values = [3, 6, 10]
    print("\n测试整数值：")
    print("-" * 60)
    print("a\t计算值 Γ(a)\t精确值 (a-1)!\t相对误差")
    print("-" * 60)
    for a in test_values:
        result = gamma_function(a) # 使用 gamma_function 而不是 gamma
        # 使用 math.factorial 而不是 np.math.factorial
        factorial_val = float(factorial(a-1)) # 转换为浮点数以便计算误差
        relative_error = abs(result - factorial_val) / factorial_val if factorial_val != 0 else 0
        print(f"{a}\t{result:<12.6e}\t{factorial_val:<12.0f}\t{relative_error:.2e}")
    print("-" * 60)

def main():
    # 绘制原始被积函数
    plot_integrands() # 使用 plot_integrands 而不是 plot_integrand

    # 运行测试
    test_gamma()

if __name__ == '__main__':
    main()
